import pandas as pd
import numpy as np

def _parse_option(problem, prefix, max_outcomes):
    ev = 0.0
    outcomes = []
    probs = []
    for i in range(1, max_outcomes + 1):
        outcome_key = f'{prefix}_outcome_{i}'
        prob_key = f'{prefix}_prob_{i}'
        raw_prob = problem.get(prob_key)
        outcome = pd.to_numeric(problem.get(outcome_key), errors='coerce')
        prob = pd.to_numeric(raw_prob, errors='coerce')
        if pd.notna(outcome) and pd.notna(prob):
            ev += outcome * prob
            outcomes.append(outcome)
            probs.append(prob)
    return ev, outcomes, probs

def predict_choice_proportions(problem):
    # Step 1 & 2: Call the helper function to parse both options
    ev_a, outcomes_a, probs_a = _parse_option(problem, 'A', 10)
    ev_b, outcomes_b, probs_b = _parse_option(problem, 'B', 10)

    # Step 3: Apply behavioral heuristics to calculate subjective utility
    utility_a, utility_b = ev_a, ev_b
    all_outcomes = outcomes_a + outcomes_b
    max_abs_outcome = max(abs(o) for o in all_outcomes) if all_outcomes else 0
    is_certain_a = len(probs_a) == 1 and probs_a[0] == 1.0
    is_certain_b = len(probs_b) == 1 and probs_b[0] == 1.0
    
    # Heuristics for gains and losses
    is_gain_domain = all(o >= 0 for o in all_outcomes) if all_outcomes else False
    has_losses = any(o < 0 for o in all_outcomes)

    if is_gain_domain and is_certain_a and max_abs_outcome > 10:
        utility_a *= 1.25

    if has_losses:
        lambda_factor = 1.05 + 1.2 * (min(max_abs_outcome, 1000) / 1000)
        
        def value_function(x):
            return x * lambda_factor if x < 0 else x
        
        utility_a = sum(value_function(o) * p for o, p in zip(outcomes_a, probs_a))
        utility_b = sum(value_function(o) * p for o, p in zip(outcomes_b, probs_b))
        
        is_certain_loss_a = is_certain_a and outcomes_a and outcomes_a[0] < 0
        is_risky_loss_b = not is_certain_b and outcomes_b and all(o <= 0 for o in outcomes_b)

        if is_certain_loss_a and is_risky_loss_b:
            # breakeven effect or big loss effect
            if utility_a == utility_b or max_abs_outcome > 10:
                risk_seeking_factor = 0.80
                utility_b *= risk_seeking_factor


    # Splitting Effect
    positive_outcomes_a = sum(1 for o in outcomes_a if o > 0)
    positive_outcomes_b = sum(1 for o in outcomes_b if o > 0)
    if not is_certain_a and not is_certain_b and is_gain_domain and positive_outcomes_b > 1 and positive_outcomes_a > 1:
        high_value_threshold = max_abs_outcome * 0.8
        high_value_count_a = sum(1 for o in outcomes_a if o >= high_value_threshold)
        high_value_count_b = sum(1 for o in outcomes_b if o >= high_value_threshold)
        if high_value_count_b > high_value_count_a:
            utility_b *= 1.10

    #Lottery Effect
    positive_outcomes_b = sum(1 for o in outcomes_b if o > 0)
    is_lottery_b = any(0 < p < 0.01 for p in probs_b)
    if is_certain_a and is_lottery_b and positive_outcomes_b <= 2:
        jackpot = max(outcomes_b, default=0)
        certain_payout = outcomes_a[0]
        if jackpot > 20 * certain_payout:
            utility_b *= 1.5

    # Step 4: Convert final utilities into choice proportions
    total_abs_ev = abs(ev_a) + abs(ev_b)
    if total_abs_ev == 0: total_abs_ev = 1

    k = 0.5 / np.log1p(total_abs_ev)

    exp_diff = np.exp(k * (utility_b - utility_a))
    prop_a = 1 / (1 + exp_diff)

    return (prop_a, 1 - prop_a)